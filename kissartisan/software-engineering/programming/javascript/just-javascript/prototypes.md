## Recap

<ul><li>When reading <code>obj.something</code>, if <code>obj</code> doesn’t have a <code>something</code> property, JavaScript will look for <code>obj.__proto__.something</code>. Then it will look for <code>obj.__proto__.__proto__.something</code>, and so on, until it either finds our property or reaches the end of the prototype chain.</li><li>When writing to <code>obj.something</code>, JavaScript will usually write to the object directly instead of traversing the prototype chain.</li><li>We can use <code>obj.hasOwnProperty('something')</code> to determine whether our object has its <em>own</em> property called <code>something</code>.</li><li>We can “pollute” a prototype shared by many objects by mutating it. We can even do this to the Object Prototype—the default prototype for <code>{}</code> objects! (But we shouldn’t, unless we’re pranking our colleagues.)</li><li>You probably won’t use prototypes much directly in practice. However, they are fundamental to JavaScript objects, so it is handy to understand their underlying mechanics. Some advanced JavaScript features, including classes, can be expressed in terms of prototypes.</li></ul>
